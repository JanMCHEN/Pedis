# Pedis
Python版Redis数据库服务器实现

根据RESP协议编写，兼容各大Redis客户端

asyncio异步单线程实现，避免了线程安全问题， 因底层select模型限制，并发量不是很大，有望进一步改进。

## 支持操作
`{'KEYS', 'DEL', 'TYPE', 'EXPIRE', 'PERSIST', 'TTL',
    'GET', 'MGET', 'SET', 'MSET', 'STRLEN',
    'HSET', 'HGET', 'HMSET', 'HMGET', 'HLEN', 'HKEYS', 'HGETALL',
    'LPUSH', 'RPUSH', 'LPOP', 'RPOP', 'LLEN', 'LINDEX', 'LSET',
    'SAVE', 'BGSAVE',}`
持续添加中。。。。。

## 食用方法
拿过去就能用，还没写客户端，但支持redis自带的客户端；当然，各种编程语言提供的redis应该也能用。

## 实现原理
### 网络
传输层用的还是TCP，所以也是基于socket编程，然后照着RESP协议封装的数据包，协议实现起来也比较简单。
并发底层实现是asyncio的select，基于事件循环，主要用asyncio异步编程比较方便，性能一般吧。
### 数据结构
比较呆，只想到用hash实现键值存储，有时间追追redis源码，我觉得肯定离不开hash的要速度的话。目前比较菜，觉得用
python实现起来会简单一点，所以用的python中UserDict，简单封装了下，用以支持不同数据类型。
### 持久化
redis官方持久化主要两种方法，pdb和aof，一个是将内存中数据序列化存储到磁盘，一个是记录每次操作追加到.aof文件。
个人觉得序列化实现起来应该会简单一点，利用pickle模块可以方便的序列化和反序列化，然后直接无脑的每次重新写到磁盘。而.aof还要考虑多条操作指令其实还可以合并到一块，这样可以减小文件大小，等等。。。还未实现
### 持久化策略
要做到数据不丢失，还需要及时把数据存储到磁盘，仿照redis实现了几个简单的策略，主要是基于能改变键值的方法记录改变量，根据改变量和时间范围决定是否执行同步。
### 键过期设置
关于键过期时间也做了个简单实现，新增了一个过期字典用以记录该键的过期时间，一过期立马删除。基于python的自动回收机制，其实此时并不是直接清理掉内存的，所以个人觉得相比于redis官方的过期清除策略这算是一种十分简便的方法了。


